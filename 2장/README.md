🌱 두 번째 기록

Node.js는 어쨋거나 자바스크립트 실행기이기 때문에, 자바스크립트 문법을 모른다면 소용이 없다.

그렇기에 저자는 자바스크립트를 처음 접해보는 것이라면 잠시 중단하고, 자바스크립트를 먼저 공부할 것을 추천한다.

하지만 ES6 문법을 어느 정도 공부하고 익숙한 나는

내가 헷갈려하는 부분 & 개념이 확실히 정리되지 않은 부분에 대해서 추가적으로 기록하려고 한다.

여기서 다루는 ES6 문법

- const, let
- 템플릿 문자열
- 객체 리터럴
- 화살표 함수
- 구조 분해 할당
- 클래스
- 프로미스 🔥
- async / await 🔥
- Map / Set 🔥
- 널 병합 / 옵셔널 체이닝 🔥

불 이모티콘… 아직 설명하기에는 부족하다..라는 개념

---

### 프로미스, Promise

프로미스를 통해서 자바스크립트와 노드의 API들이 콜백 대신 프로미스 기반으로 재구성되었다.

(콜백 지옥에서 벗어남..!)

프로미스의 규칙

1. 프로미스 객체를 생성 → **`new Promise`**((resolve, reject) ⇒ { … })
2. `resolve` 호출 : then 실행 + `reject` 호출 : catch 실행 + `finally` : 성공,실패 여부와 상관없이 실행
3. new Promise와 promise.then 사이에는 다른 코드가 들어가는 것이 가능

프로미스를 쉽게 설명하자면,

<aside>
💡 실행은 바로 하되, 결괏값은 나중에 받는(then, catch 메소드를 통해) 객체

</aside>

프로미스 여러 개를 한 번에 실행 할 수 있는 방법이 존재! → `Promise.allSettled()`를 활용!

여러 개의 프로미스들 중에서 어떤 프로미스가 reject되었는지 정확하게 알 수 있다.

<br>

### async / await

프로미스를 사용해서 코드의 깊이가 깊어지는 문제가 해결되었지만,

여전히 반복되는 then, catch 때문에 코드의 길이가 길어지는 문제가 남아있다.

이럴 때 장황한 프로미스 코드를 `async`, `await`를 사용하면 눈에 띄게 줄일 수 있다.

async, await 사용 방법

1. 함수 선언부를 function 대신 `async function`으로 선언한다.
2. 함수 내부의 프로미스 앞에 await을 붙인다. → 해당 프로미스가 resolve될때까지 기다린 후 다음으로 넘어감
3. `try, catch` 문으로 함수 내부를 감싸준다 → 프로미스가 reject될때의 처리

앞으로 중첩되는 콜백 함수가 있다면 async, await를 사용해서 코드를 간결하고 효율적이게 바꾸면 좋다.

<br>

### Map / Set

Map과 Set은 각각 객체, 배열과 유사하다고 생각하면 편하다.

Map / Set의 특징

1. `Map` : 속성들 간의 순서를 보장 + 반복문을 사용하는 것이 가능
2. `Set` : 중복을 허용하지 않는다. → 배열의 중복된 요소를 제거하고 싶을 때 유용!

<br>

### 널 병합 / 옵셔널 체이닝

- 널 병합(nullish coalescing) : `??` 연산자
  - 주로 || 연산자의 대용으로 사용되며, false value중에서 **null, undefined를 구분**하는 용도로 사용
- 옵셔널 체이닝(optional chaining) : `?.` 연산자
  - null, undefined의 속성을 조회하는 경우 **에러(TypeError)가 발생하는 것을 막는 용도**로 사용
  - 옵셔널 체이닝의 결과값은 **undefined**가 된다.
